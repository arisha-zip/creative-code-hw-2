I didn’t exactly start my game off with a specific vision thematically; more so, I just had general references I wanted my game to emulate mechanics-wise. My inspirations were Geometry Dash and the T-Rex game that Google Chrome provides when you run a browser offline. Both are somewhat more simplified versions of a side-scrolling platformer game, which, in terms of applying logic, felt achievable based on the examples I’d seen in class within the past few weeks.

I used the Pong game logic to help me get a grasp of how to move an object back and forth, but constrained player movement primarily to the x-axis. Thinking about both that and what I learned in Ch. 5 of Learning Processing on conditionals, I used boundaries to limit how far along the screen the player could move to start creating a story for my game. 

I referenced a ton of video tutorials during the first half of making this game, sourced from video series made by John McCaffrey, Allen Thoe, or Chris Whitmire (all on YouTube).

Refering back to the games I used as inspiration, I knew I wanted my game to feel a bit more free-flowing, rather than have the character stay stationary with obstacles moving towards them. I referenced https://youtu.be/jgr31WIYWdk?si=o1D9xvXMjZyDL5uc & https://youtu.be/8uCXGcWK4BA?si=GyEe-qEdo3US_k2T, using the left and right arrow keys to guide them. Furthering the lore I was creating for this, I wanted the character to move through some sort of environment, so I created a long background in Adobe Illustrator that would scroll horizontally as the game was being played (referenced https://youtu.be/IIrGAvlNckw?si=ak11GiuuY9M4Rhvl). In creating this motion, I realized there was a clash in terms of actual visual logic, as the character being able to move back and forth while the background only moved horizontally wasn’t making much sense. Debating whether or not to keep the background static or moving horizontally, I eventually came to the conclusion that I could make the background move vertically, and revisit the actual illustration of said background later.  

At this point I’d crafted a main tab, and then another tab for my player, or “person” class. I created another tab for my obstacle class, and then ideated how I wanted it to interact with my person. I started off with a simple collision, only using squares at that point since I was using a video tutorial that focused on rectangle-based collisions (I later had to adjust this): https://www.youtube.com/watch?v=C0qfEdE0r7o. 

I then added in motion for the obstacles, factoring my random elements, having them come in sporadically at my person from both the left and right side. For this, I ended creating an array, and played around with making the colors of the squares random. I simplified this later in my process, as I’d realized I wanted to make only 3 distinct different types of obstacles, associating them with different illustrated sprites. What I settled on was squares of different sizes, one being the same size as the person (50x50 px), a slighter larger one (65 x 65 px), and then an even bigger one (85 x 85 px). I realized having the obstacles coming from both sides made the game a little too hard (at least for my standards), so I settled on just having them enter from the right. 

To indicate visual feedback, I wanted to show a timer in the corner (which would also communicate the player’s score) as well as the amount of lives they had; This would decrease for every collision the player would have with the obstacles. To create the timer, I used the millis() function, displaying the score in seconds (https://processing.org/reference/millis_.html). 

To help outline game states (referenced: https://youtu.be/q8rP6R0LCss?si=Pp1TEyjLmmgg2zjm), I created 4 separate ones (start, play, end, win), and had the game reload based on a mouse press (restarting both the timer and count of lives left).

I knew from the beginning that I wanted to increase difficulty as the game progressed, but wasn’t 100% sure as to how. What I settled on was making the intervals between each obstacle spawn decrease as you played for longer. This played into my vague vision that I wanted the background to be a sky, with the game getting harder as you move further into the night). I created another long background, and timed the speed so that covering the entire span of the sky would last around 2 minutes (and at the end of the two minutes you win the game). The intervals would decrease every 20 seconds. 

To add in another random collision element, I added a simple powerup (labelled as “heart”), which functioned very similarly to my obstacles, except for the fact that there was no variation in size, and the frequency in which they would randomly spawn was a bit more rare. The collision between the player and the heart operated opposite to the obstacle collision, adding a life instead of taking one away. I also decided to cap the number of lives a player could earn to 5, to add more constraints to the game. 

Another feature I had to do a bit more research to implement was the reflection of my person as they flipped from left vs. right. I looked through the processing library and added in a pushMatrix() and popMatrix() (referenced: https://processing.org/tutorials/transform2d#the-transformation-matrix). 

To add more variability and emotion to my game, I played around a bit with motion, ending up with having my obstacles come in at slightly different heights along the x-axis, which would influence the player’s behavior in having them jump and avoid them. Once I decided that the obstacles themselves were going to be aliens, I looked through some of the examples on Blackboard and decided to implement some trig-based functions, utilizing multiple different frequencies to emulate a more float-like, wavy motion for the obstacles. I also decided to apply this motion to the heart power-up as well. For the person, I utilized the ‘Basic Game Physics Explainer’ to create a more realistic jump feature (adjusting the velocity). 

The game aesthetics themselves were something I decided to focus on as a third act in terms of my design process, which, in retrospect, perhaps made my ideation phase of the game itself a bit more unorganized, as I essentially ended up creating a theme for the game based on the basic mechanics I decided to settle on- but in a way, I suppose it did force me to get creative, finding a game plot that matched up with what I’d already spent time coding.

For my sound elements (referenced: https://processing.org/reference/libraries/sound/SoundFile.html), I found my power-up sounds on http://freesound.org/, adding in an effect for when there was a collision with the heart power-up (https://freesound.org/people/mondofred/sounds/416386/) and the alien obstacles (https://freesound.org/people/moogy73/sounds/425699/). For background music, I found a song in an old playlist of mine, called ‘Ghost Waltz’ by Louie Zong, which, after deciding on an alien theme, I thought fit in really well for the audio. Credits to him for the song! I ended up purchasing it from Bandcamp for only $1.50. I also got really lucky in terms of song length, as it was just about 2 minutes long. 

All my illustrations for the game were made in Procreate, which I made sure to size my canvas based on how large each element was, pixel-wise, and I again used the processing library to help me add them in (https://processing.org/reference/loadImage_.html).  

I referenced ChatGPT when I ran into issues in trying to make my game run more efficiently without crashing, and one aspect it suggested was making sure my elements weren’t loaded when they were off-screen, which definitely helped. There was also a suggestion to have my obstacle movement loop backwards, which would allow me to more easily adjust the settings of my game in the future (another feature I ultimately decided to implement). 

When it came to porting my sketch into p5.js, the two main issues I ran into were: 1. My images not loading in (which, after inspecting the page, I ended up just moving my assets to a separate folder, relinking them, and creating copies of them for my processing file), and 2. The floaty effect of my game becoming a lot faster than I’d thought it would be in my html page. The jump feature in my Processing version, for example, emulated a lot more of a calm, whimsical feel, as the gravity didn’t appear to pull down the character as fast. This could, perhaps, be attributed to the amount of images I was loading in, whereas my p5.js version was a lot smoother. While not the end of the world, the difference provided a much different feeling tonally. The background also seemed to move a lot faster, compared to the Processing version of my sketch; the full scroll lasted just about 2 minutes, while in my html page, it went through the whole thing in about 46 seconds. Troubleshooting something like this is something that perhaps requires a bit more knowledge on data structures and the bones of my actual code, which is something I hope to learn more about in the future. 

All in all though, I’m pretty happy with what I came up with, I learned so much, and this project is definitely something I plan to reiterate and expand in the future!
